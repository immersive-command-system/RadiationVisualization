using System.Collections.Generic;

using UnityEngine;

using SimpleJSON;
using ROSBridgeLib;
using ROSBridgeLib.cartographer_msgs;

/// <summary>
/// A rosbridge client class that monitors the list of submaps generated by cartographer_ros,
/// fetches them, and displays them.
/// </summary>
public class SubmapConnection : MonoBehaviour, ROSTopicSubscriber
{
    /// <value> The network address of the computer running rosbrdige and cartographer_ros.</value>
    public string rosbridgeAddress = "128.32.43.94";
    /// <value> The port that rosbridge operates on.</value>
    public int rosbridgePort = 9090;
    /// <value> The name of the topic where the list of submaps and their statuses are broadcasted.</value>
    public string submapListTopic = "submap_list";
    /// <value> the name of the service to request the point cloud of a specific point cloud.</value>
    public string submapServiceName = "submap_cloud_query";

    /// <value> Whether the point clouds returned by cartographer have their y and z dimensions swapped.</value>
    public bool flipYZ
    {
        get
        {
            return _flipYZ;
        }
        set
        {
            _flipYZ = value;
            transform.rotation = Quaternion.Euler((_flipYZ) ? -90 : 0, 0, 0);
        }
    }
    private bool _flipYZ;

    /// <value> The number of submap point cloud map requests allowed to be "in-flight" at any time. </value>
    public int maxConcurrentMapRequests = 1;

    /// <value> The probability/certainty a point should have for cartographer to include it in the point cloud of a submap.</value>
    public float threshold_probability = 0.95f;

    /// <value> A mapping from submap index to the version of the submap locally stored/displayed.</value>
    private Dictionary<int, int> submap_versions = new Dictionary<int, int>();
    /// <value>
    /// A mapping from submap index to the SubmapEntryMsg with the metadata of the newest map available,
    /// as broadcasted on the submap list topic of cartographer.
    /// </value>
    private Dictionary<int, SubmapEntryMsg> newest_version = new Dictionary<int, SubmapEntryMsg>();
    /// <value> A mapping from submap index to the visualizer object responsible for displaying it.</value>
    private Dictionary<int, SubmapVisualizer> visualizers = new Dictionary<int, SubmapVisualizer>();
    /// <value> A mapping from the id string associated with a submap service request to the SubmapEntryMsg representing the submap of that request.</value>
    /// <remarks> These are the requests that are in flight. It's size should never exceed maxConcurrentMapRequests.</remarks>
    private Dictionary<string, SubmapEntryMsg> pending_submaps = new Dictionary<string, SubmapEntryMsg>();

    /// <value> The web socket object directly responsible for communicating with ROS.</value>
    /// <remarks> If there is an object with ROSBridgeConnectionManager active in the scene, this field should be auto-populated.</remarks>
    private ROSBridgeWebSocketConnection connection = null;

    // Use this for initialization
    void Start()
    {
        flipYZ = true;
        GetConnection();
    }

    /// <summary>
    /// Attempt to obtain the ROSBridgeConnection object with ROSBridge
    /// </summary>
    void GetConnection()
    {
        if (connection == null)
        {
            // Attempt to obtain a connection object.
            ROSBridgeConnectionsManager manager = ROSBridgeConnectionsManager.Instance;
            if (manager != null)
            {
                connection = manager.GetConnection(rosbridgeAddress, rosbridgePort);
                connection.AddSubscriber(submapListTopic, this);
            }
        }
    }

    // Update is called once per frame in Unity
    // TODO: Need to drop requests that are taking too long to respond. Otherwise it may block up all submap updating.
    void Update()
    {
        // Call GetConnection() again just in case the call at Start() was not successful (eg. ros connection manager not active yet).
        GetConnection();

        if (pending_submaps.Count < maxConcurrentMapRequests)
        {
            // Pick a submap to update, prioritizing new submaps and most outdated ones.
            int minIndex = -1;
            int maxDifference = 0;
            SubmapEntryMsg needed_submap = null;
            foreach (KeyValuePair<int, SubmapEntryMsg> curr in newest_version)
            {
                bool already_pending = false;
                foreach (SubmapEntryMsg pending in pending_submaps.Values)
                {
                    if (pending.submap_index == curr.Key)
                    {
                        already_pending = true;
                        break;
                    }
                }
                if (already_pending)
                {
                    continue;
                }

                if (!submap_versions.ContainsKey(curr.Key))
                {
                    minIndex = curr.Key;
                    needed_submap = curr.Value;
                    break;
                }
                int currDiff = curr.Value.submap_version - submap_versions[curr.Key];
                if (currDiff > maxDifference)
                {
                    minIndex = curr.Key;
                    maxDifference = currDiff;
                    needed_submap = curr.Value;
                }
            }
            if (minIndex >= 0)
            {
                string id = submapServiceName + " " + needed_submap.submap_index + "." + needed_submap.submap_version;
                pending_submaps[id] = needed_submap;
                //Debug.Log("Requestiong Submap: " + pending_submap.submap_index);
                connection.CallService(HandleSubmapServiceResponse, submapServiceName, id, string.Format("[{0}, {1}, {2}, false]", needed_submap.trajectory_id, minIndex, threshold_probability));
            }
        }
    }

    /// <summary>
    /// Callback function for the submap point cloud service requiest.
    /// </summary>
    /// <param name="response">The response of the submap point cloud query service.</param>
    void HandleSubmapServiceResponse(JSONNode response)
    {
        SubmapEntryMsg targetEntry;
        // Check that this is a response to a pending submap request.
        if (!pending_submaps.TryGetValue(response["id"].Value, out targetEntry))
        {
            return;
        }
        pending_submaps.Remove(response["id"].Value);
        SubmapCloudMsg cloudMsg = new SubmapCloudMsg(response["values"]);
        HandleSubmapMessage(targetEntry, cloudMsg);
    }

    /// <summary>
    /// Helper function to actually process the submap point cloud message and display it.
    /// </summary>
    /// <param name="entry">The metadata of the submap to be displayed.</param>
    /// <param name="msg">The message containing the actual contents/data of the associated submap.</param>
    void HandleSubmapMessage(SubmapEntryMsg entry, SubmapCloudMsg msg)
    {
        // Do nothing if there is already a more recent version of the submap locally.
        // This might be possible if two requests for the same submap_index are sent
        // and the response for the more recent submap arrives first.
        if (submap_versions.ContainsKey(entry.submap_index) && 
            submap_versions[entry.submap_index] >= entry.submap_version)
        {
            return;
        }

        GameObject obj;
        SubmapVisualizer vis;
        // Create a new visualizer object for this submap if one doesn't exist already.
        if (!visualizers.ContainsKey(entry.submap_index))
        {
            obj = new GameObject();
            obj.transform.parent = transform;
            vis = obj.AddComponent<SubmapVisualizer>();
            visualizers.Add(entry.submap_index, vis);
        }
        // Otherwise just update the existing one.
        else
        {
            vis = visualizers[entry.submap_index];
            obj = vis.gameObject;
        }

        obj.transform.position = transform.position + (new Vector3(
            entry.pose._position.GetX(),
            entry.pose._position.GetY(),
            entry.pose._position.GetZ()));
        obj.transform.rotation = transform.rotation * (new Quaternion(
            entry.pose._orientation.GetX(),
            entry.pose._orientation.GetY(),
            entry.pose._orientation.GetZ(),
            entry.pose._orientation.GetW()));

        vis.UpdateMap(msg.cloud.GetCloud());

        submap_versions[entry.submap_index] = entry.submap_version;
    }

    /// <summary>
    /// Helper function to handle a list of submap statuses as broadcasted by cartographer_ros.
    /// </summary>
    /// <param name="msg">The list of submap metadata.</param>
    void HandleSubmapList(SubmapListMsg msg)
    {
        foreach (SubmapEntryMsg submapEntry in msg.submap_entries)
        {
            HandleSubmapEntry(submapEntry);
        }
    }

    /// <summary>
    /// Helper function to handle the version advertisement for each submap in the submaps status broadcast.
    /// </summary>
    /// <param name="msg">The submap entry to process.</param>
    void HandleSubmapEntry(SubmapEntryMsg msg)
    {
        if (!newest_version.ContainsKey(msg.submap_index) ||
            msg.submap_version > newest_version[msg.submap_index].submap_version)
        {
            newest_version[msg.submap_index] = msg;
        }
    }

    /// <summary>
    /// Callback method to handle receiving a message on a topic subscribed to.
    /// </summary>
    /// <param name="topic">The topic this message is from.</param>
    /// <param name="raw_msg">The json object representing the raw message.</param>
    /// <param name="parsed">A pre-parsed ROSBridgeMsg, if another object has already parsed it. Possibly null.</param>
    /// <remarks>In this class, this callback method handles the submap list message.</remarks>
    /// <returns>
    /// The parsed message (a subclass of ROSBridgeMsg). In this case it is a SubmapListMsg object.
    /// This will be passed as the parsed param to other subscribers this message is given to for convenience/performance.
    /// </returns>
    public ROSBridgeMsg OnReceiveMessage(string topic, JSONNode raw_msg, ROSBridgeMsg parsed = null)
    {
        if (topic.Equals(submapListTopic))
        {
            SubmapListMsg submapList;
            if (parsed == null)
            {
                submapList = new SubmapListMsg(raw_msg);
            } else
            {
                submapList = (SubmapListMsg)parsed;
            }
            HandleSubmapList(submapList);
            return submapList;
        }
        return parsed;
    }

    /// <summary>
    /// Get the message type of each topic this class subscribes to.
    /// </summary>
    /// <param name="topic"></param>
    /// <returns></returns>
    public string GetMessageType(string topic)
    {
        if (topic.Equals(submapListTopic))
        {
            return "cartographer_ros_msgs/SubmapList";
        }
        return "";
    }
}
